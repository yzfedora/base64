/*
 * Base64 encode and decode API.
 *
 * 	Copyright (c) 2018 YangZhang <yzfedora@gmail.com>
 *
 * Python script for generate the base64 encode and decode table.
 *
 * 	import string
 *
 * 	encode_table = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'
 * 	decode_table = []
 *
 * 	for i in range(0, 256):
 * 	    c = chr(i)
 * 	    if c in encode_table:
 * 	        decode_table.append(encode_table.index(c))
 * 	    else:
 * 	        decode_table.append(0)
 *
 * 	print '---Base64 Encode Table---'
 * 	for i in range(0, 8):
 * 	    line = []
 * 	    for j in range(0, 8):
 * 	        line.append('0x{:02x},'.format(ord(encode_table[i * 8 + j])))
 *
 * 	    print ' '.join(line)
 *
 *
 * 	print '---Base64 Decode Table---'
 * 	for i in range(0, 32):
 * 	    line = []
 * 	    for j in range(0, 8):
 * 	        line.append('0x{:02x},'.format(decode_table[i * 8 + j]))
 *
 * 	    print ' '.join(line)
 *
 */
#include <string.h>

#include "base64.h"


static const char b64e[] = {
	0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
	0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
	0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
	0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
	0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
	0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
	0x77, 0x78, 0x79, 0x7a, 0x30, 0x31, 0x32, 0x33,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2b, 0x2f,
};

static const int b64d[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
	0x3c, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
	0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
	0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

int base64_encode(const void *src, size_t n, char *buf, size_t bufsz)
{
	size_t length_max = base64_encode_length_max(n);

	if (bufsz < length_max + 1)	/* include trailing 0 */
		return -1;

	for (size_t i = 0; i < n / 3; i++) {
		uint8_t a = ((uint8_t *)src)[i * 3 + 0];
		uint8_t b = ((uint8_t *)src)[i * 3 + 1];
		uint8_t c = ((uint8_t *)src)[i * 3 + 2];

		buf[i * 4 + 0] = b64e[((a & 0xfc) >> 2)];
		buf[i * 4 + 1] = b64e[((a & 0x03) << 4) | ((b & 0xf0) >> 4)];
		buf[i * 4 + 2] = b64e[((b & 0x0f) << 2) | ((c & 0xc0) >> 6)];
		buf[i * 4 + 3] = b64e[((c & 0x3f) << 0)];
	}

	if (n % 3 == 2) {
		uint8_t a = ((uint8_t *)src)[n - 2];
		uint8_t b = ((uint8_t *)src)[n - 1];
		buf[length_max - 4] = b64e[((a & 0xfc) >> 2)];
		buf[length_max - 3] = b64e[((a & 0x03) << 4) | ((b & 0xf0) >> 4)];
		buf[length_max - 2 ] = b64e[((b & 0x0f) << 2)];
		buf[length_max - 1] = '=';
	} else if (n % 3 == 1) {
		uint8_t a = ((uint8_t *)src)[n - 1];
		buf[length_max - 4] = b64e[(a & 0xfc) >> 2];
		buf[length_max - 3] = b64e[(a & 0x03) << 4];
		buf[length_max - 2] = '=';
		buf[length_max - 1] = '=';
	}

	buf[length_max] = 0;
	return 0;
}

int base64_decode(const char *src, size_t n, void *buf, size_t bufsz)
{
	/*
	 * The buffer size has to be greater than the maximum length of decode
	 * result. so we can ignore the check of trailing "=". in the decode
	 * table, "=" is mapped to 0.
	 */
	if (bufsz < base64_decode_length_max(n))
		return -1;

	for (size_t i = 0; i < n / 4; i++) {
		uint8_t a = b64d[(uint8_t)src[i * 4 + 0]];
		uint8_t b = b64d[(uint8_t)src[i * 4 + 1]];
		uint8_t c = b64d[(uint8_t)src[i * 4 + 2]];
		uint8_t d = b64d[(uint8_t)src[i * 4 + 3]];

		((uint8_t *)buf)[i * 3 + 0] = ((a & 0x3f) << 2) | ((b & 0x30) >> 4);
		((uint8_t *)buf)[i * 3 + 1] = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);
		((uint8_t *)buf)[i * 3 + 2] = ((c & 0x03) << 6) | ((d & 0x3f) >> 0);
	}

	return 0;
}

#if 0
int main(int argc, char **argv)
{
	char enc[1 << 20], dec[1 << 20];

	if (base64_encode(argv[1], strlen(argv[1]), enc, sizeof(enc)) < 0) {
		fprintf(stderr, "Base64 encode failed: Insufficient buffer size\n");
		return 1;
	}

	printf("---Base64 Encode Result---\n");
	printf("%s\n", enc);

	if (base64_decode(enc, strlen(enc), dec, sizeof(dec)) < 0) {
		fprintf(stderr, "Base64 encode failed: Insufficient buffer size\n");
		return 1;
	}

	printf("---Base64 Decode Result---\n");
	printf("%s\n", dec);
	return 0;
}
#endif
